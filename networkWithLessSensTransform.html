<!-- <!DOCTYPE html>
<html>
<head>
  <title>3D Random Network with Reduced Sensitivity</title>
  <style>
    body { margin: 0; overflow: hidden; background: black; }
    canvas { display: block; }
    .controls {
      position: absolute;
      top: 10px;
      left: 10px;
      color: white;
      font-family: Arial, sans-serif;
      background: rgba(0, 0, 0, 0.7);
      padding: 10px;
      border-radius: 5px;
      max-width: 300px;
    }
    button {
      background: #444;
      color: white;
      border: none;
      padding: 5px 10px;
      margin: 5px;
      cursor: pointer;
      border-radius: 3px;
    }
    button:hover {
      background: #666;
    }
    input, select {
      margin: 5px;
      padding: 3px;
      width: 180px;
    }
    label {
      display: block;
      margin-top: 8px;
    }
    .tips {
      font-size: 12px;
      margin-top: 10px;
      padding-top: 10px;
      border-top: 1px solid #444;
    }
  </style>
</head>
<body>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <div class="controls">
    <label for="pointCount">Number of Points: <span id="pointCountValue">300</span></label>
    <input type="range" id="pointCount" min="50" max="1000" value="300" step="50">
    
    <label for="connectionCount">Random Connections: <span id="connectionCountValue">3</span></label>
    <input type="range" id="connectionCount" min="1" max="10" value="3">
    
    <label for="connectionDistance">Connection Distance: <span id="connectionDistanceValue">100</span></label>
    <input type="range" id="connectionDistance" min="20" max="300" value="100" step="10">
    
    <label for="rotationSensitivity">Rotation Sensitivity: <span id="rotationSensitivityValue">50</span>%</label>
    <input type="range" id="rotationSensitivity" min="10" max="100" value="50">
    
    <label for="autoRotate">Auto-Rotate:</label>
    <input type="checkbox" id="autoRotate" checked>
    
    <button id="resetBtn">Generate New Network</button>
    
    <div class="tips">
      <strong>Controls:</strong><br>
      - Mouse drag: Rotate view<br>
      - Mouse wheel: Zoom in/out<br>
      - Shift + drag: Pan view<br>
      - Double-click: Reset view
    </div>
  </div>
  <script>
    // Get UI elements
    const pointCountSlider = document.getElementById('pointCount');
    const pointCountValue = document.getElementById('pointCountValue');
    const connectionCountSlider = document.getElementById('connectionCount');
    const connectionCountValue = document.getElementById('connectionCountValue');
    const connectionDistanceSlider = document.getElementById('connectionDistance');
    const connectionDistanceValue = document.getElementById('connectionDistanceValue');
    const rotationSensitivitySlider = document.getElementById('rotationSensitivity');
    const rotationSensitivityValue = document.getElementById('rotationSensitivityValue');
    const autoRotateCheckbox = document.getElementById('autoRotate');
    const resetBtn = document.getElementById('resetBtn');
    
    // Network parameters
    let numPoints = parseInt(pointCountSlider.value);
    let connectionsPerPoint = parseInt(connectionCountSlider.value);
    let connectionDistance = parseInt(connectionDistanceSlider.value);
    let rotationSensitivity = parseInt(rotationSensitivitySlider.value) / 100;
    
    // Update display values
    pointCountSlider.addEventListener('input', function() {
      pointCountValue.textContent = this.value;
    });
    
    connectionCountSlider.addEventListener('input', function() {
      connectionCountValue.textContent = this.value;
    });
    
    connectionDistanceSlider.addEventListener('input', function() {
      connectionDistanceValue.textContent = this.value;
    });
    
    rotationSensitivitySlider.addEventListener('input', function() {
      rotationSensitivityValue.textContent = this.value;
      rotationSensitivity = parseInt(this.value) / 100;
    });
    
    // Setup THREE.js scene
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 2000);
    camera.position.z = 500;
    
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(window.devicePixelRatio);
    document.body.appendChild(renderer.domElement);
    
    // Create group to hold all objects
    const networkGroup = new THREE.Group();
    scene.add(networkGroup);
    
    // Variables for transformations
    let isDragging = false;
    let previousMousePosition = { x: 0, y: 0 };
    let isPanning = false;
    let rotationSpeed = { x: 0, y: 0 };
    const damping = 0.95;
    
    // Create the network with randomly distributed points
    function createNetwork() {
      // Clear previous network
      while(networkGroup.children.length > 0) {
        const object = networkGroup.children[0];
        if (object.geometry) object.geometry.dispose();
        if (object.material) object.material.dispose();
        networkGroup.remove(object);
      }
      
      // Update parameters
      numPoints = parseInt(pointCountSlider.value);
      connectionsPerPoint = parseInt(connectionCountSlider.value);
      connectionDistance = parseInt(connectionDistanceSlider.value);
      
      // Create points with completely random distribution
      const pointsGeometry = new THREE.BufferGeometry();
      const positions = [];
      const pointSizes = [];
      
      for (let i = 0; i < numPoints; i++) {
        // Completely random position in a cube
        const x = (Math.random() - 0.5) * 400;
        const y = (Math.random() - 0.5) * 400;
        const z = (Math.random() - 0.5) * 400;
        
        positions.push(x, y, z);
        
        // Varied point sizes
        pointSizes.push(Math.random() * 2 + 1);
      }
      
      pointsGeometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
      
      // Create material with size attenuation for better depth perception
      const pointsMaterial = new THREE.PointsMaterial({
        color: 0xffffff,
        size: 2,
        sizeAttenuation: true,
        transparent: true,
        opacity: 0.8
      });
      
      const pointsSystem = new THREE.Points(pointsGeometry, pointsMaterial);
      networkGroup.add(pointsSystem);
      
      // Create random connections
      const positionArray = pointsGeometry.attributes.position.array;
      
      // First, create fixed random connections per point
      for (let i = 0; i < numPoints; i++) {
        const sourceIndex = i * 3;
        const sourcePoint = new THREE.Vector3(
          positionArray[sourceIndex],
          positionArray[sourceIndex + 1],
          positionArray[sourceIndex + 2]
        );
        
        // Create random connections for each point
        const connectedPoints = new Set();
        
        for (let c = 0; c < connectionsPerPoint; c++) {
          // Get random target point that's not already connected
          let targetIndex;
          do {
            targetIndex = Math.floor(Math.random() * numPoints);
          } while (targetIndex === i || connectedPoints.has(targetIndex));
          
          connectedPoints.add(targetIndex);
          
          targetIndex *= 3;
          const targetPoint = new THREE.Vector3(
            positionArray[targetIndex],
            positionArray[targetIndex + 1],
            positionArray[targetIndex + 2]
          );
          
          // Create line geometry
          const lineGeometry = new THREE.BufferGeometry().setFromPoints([sourcePoint, targetPoint]);
          
          const lineMaterial = new THREE.LineBasicMaterial({
            color: 0xffffff,
            transparent: true,
            opacity: 0.15
          });
          
          const line = new THREE.Line(lineGeometry, lineMaterial);
          networkGroup.add(line);
        }
      }
      
      // Then, create proximity-based connections
      for (let i = 0; i < numPoints; i++) {
        const sourceIndex = i * 3;
        const sourcePoint = new THREE.Vector3(
          positionArray[sourceIndex],
          positionArray[sourceIndex + 1],
          positionArray[sourceIndex + 2]
        );
        
        for (let j = i + 1; j < numPoints; j++) {
          const targetIndex = j * 3;
          const targetPoint = new THREE.Vector3(
            positionArray[targetIndex],
            positionArray[targetIndex + 1],
            positionArray[targetIndex + 2]
          );
          
          // Calculate distance
          const distance = sourcePoint.distanceTo(targetPoint);
          
          // Create connection if within range
          if (distance < connectionDistance) {
            // Calculate opacity based on distance
            const opacity = 0.3 * (1 - (distance / connectionDistance));
            
            // Create line geometry
            const lineGeometry = new THREE.BufferGeometry().setFromPoints([sourcePoint, targetPoint]);
            
            const lineMaterial = new THREE.LineBasicMaterial({
              color: 0xffffff,
              transparent: true,
              opacity: opacity
            });
            
            const line = new THREE.Line(lineGeometry, lineMaterial);
            networkGroup.add(line);
          }
        }
      }
    }
    
    // Initial creation
    createNetwork();
    
    // Handle controls
    resetBtn.addEventListener('click', createNetwork);
    
    // Mouse controls
    const mousePosition = new THREE.Vector2();
    let zoomLevel = 1;
    
    renderer.domElement.addEventListener('mousedown', onMouseDown);
    renderer.domElement.addEventListener('mousemove', onMouseMove);
    renderer.domElement.addEventListener('mouseup', onMouseUp);
    renderer.domElement.addEventListener('wheel', onWheel);
    renderer.domElement.addEventListener('dblclick', resetCamera);
    
    function onMouseDown(event) {
      isDragging = true;
      isPanning = event.shiftKey;
      previousMousePosition = {
        x: event.clientX,
        y: event.clientY
      };
    }
    
    function onMouseMove(event) {
      mousePosition.x = (event.clientX / window.innerWidth) * 2 - 1;
      mousePosition.y = -(event.clientY / window.innerHeight) * 2 + 1;
      
      if (isDragging) {
        const deltaMove = {
          x: event.clientX - previousMousePosition.x,
          y: event.clientY - previousMousePosition.y
        };
        
        if (isPanning) {
          // Pan (translate) the network - with reduced sensitivity
          const panSpeed = 0.3 / camera.zoom;
          networkGroup.position.x += deltaMove.x * panSpeed;
          networkGroup.position.y -= deltaMove.y * panSpeed;
        } else {
          // Rotate the network - with adjustable sensitivity
          rotationSpeed.x = deltaMove.y * 0.002 * rotationSensitivity;
          rotationSpeed.y = deltaMove.x * 0.002 * rotationSensitivity;
          
          networkGroup.rotation.x += rotationSpeed.x;
          networkGroup.rotation.y += rotationSpeed.y;
        }
        
        previousMousePosition = {
          x: event.clientX,
          y: event.clientY
        };
      }
    }
    
    function onMouseUp() {
      isDragging = false;
      isPanning = false;
    }
    
    function onWheel(event) {
      event.preventDefault();
      
      // Zoom speed - reduced sensitivity
      const zoomSpeed = 0.05;
      
      // Calculate zoom factor
      zoomLevel -= Math.sign(event.deltaY) * zoomSpeed;
      zoomLevel = Math.max(0.2, Math.min(zoomLevel, 5));
      
      // Apply zoom to camera
      camera.zoom = zoomLevel;
      camera.updateProjectionMatrix();
    }
    
    function resetCamera() {
      networkGroup.rotation.set(0, 0, 0);
      networkGroup.position.set(0, 0, 0);
      camera.position.set(0, 0, 500);
      zoomLevel = 1;
      camera.zoom = 1;
      camera.updateProjectionMatrix();
    }
    
    // Animation loop
    function animate() {
      requestAnimationFrame(animate);
      
      // Apply damping to rotation speed
      rotationSpeed.x *= damping;
      rotationSpeed.y *= damping;
      
      // Apply auto-rotation if enabled - reduced sensitivity
      if (autoRotateCheckbox.checked) {
        networkGroup.rotation.y += 0.001;
      }
      
      // Apply momentum-based rotation
      networkGroup.rotation.x += rotationSpeed.x;
      networkGroup.rotation.y += rotationSpeed.y;
      
      renderer.render(scene, camera);
    }
    
    animate();
    
    // Handle window resize
    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });
    
    // Apply changes when sliders change
    pointCountSlider.addEventListener('change', createNetwork);
    connectionCountSlider.addEventListener('change', createNetwork);
    connectionDistanceSlider.addEventListener('change', createNetwork);
  </script>
</body>
</html> -->


<!DOCTYPE html>
<html>
<head>
  <title>3D Random Network with Reduced Sensitivity</title>
  <style>
    body { margin: 0; overflow: hidden; background: black; }
    canvas { display: block; }
    .controls {
      position: absolute;
      top: 10px;
      left: 10px;
      color: white;
      font-family: Arial, sans-serif;
      background: rgba(0, 0, 0, 0.7);
      padding: 10px;
      border-radius: 5px;
      max-width: 300px;
    }
    button {
      background: #444;
      color: white;
      border: none;
      padding: 5px 10px;
      margin: 5px;
      cursor: pointer;
      border-radius: 3px;
    }
    button:hover {
      background: #666;
    }
    input, select {
      margin: 5px;
      padding: 3px;
      width: 180px;
    }
    label {
      display: block;
      margin-top: 8px;
    }
    .tips {
      font-size: 12px;
      margin-top: 10px;
      padding-top: 10px;
      border-top: 1px solid #444;
    }
  </style>
</head>
<body>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <div class="controls">
    <label for="pointCount">Number of Points: <span id="pointCountValue">300</span></label>
    <input type="range" id="pointCount" min="50" max="1000" value="300" step="50">
    
    <label for="connectionCount">Random Connections: <span id="connectionCountValue">3</span></label>
    <input type="range" id="connectionCount" min="1" max="10" value="3">
    
    <label for="connectionDistance">Connection Distance: <span id="connectionDistanceValue">100</span></label>
    <input type="range" id="connectionDistance" min="20" max="300" value="100" step="10">
    
    <label for="rotationSensitivity">Rotation Sensitivity: <span id="rotationSensitivityValue">50</span>%</label>
    <input type="range" id="rotationSensitivity" min="10" max="100" value="50">
    
    <label for="zoomSensitivity">Zoom Sensitivity: <span id="zoomSensitivityValue">50</span>%</label>
    <input type="range" id="zoomSensitivity" min="10" max="100" value="50">
    
    <label for="autoRotate">Auto-Rotate:</label>
    <input type="checkbox" id="autoRotate" checked>
    
    <button id="resetBtn">Generate New Network</button>
    
    <div class="tips">
      <strong>Controls:</strong><br>
      - Mouse drag: Rotate view<br>
      - Mouse wheel: Zoom in/out<br>
      - Shift + drag: Pan view<br>
      - Double-click: Reset view
    </div>
  </div>
  <script>
    // Get UI elements
    const pointCountSlider = document.getElementById('pointCount');
    const pointCountValue = document.getElementById('pointCountValue');
    const connectionCountSlider = document.getElementById('connectionCount');
    const connectionCountValue = document.getElementById('connectionCountValue');
    const connectionDistanceSlider = document.getElementById('connectionDistance');
    const connectionDistanceValue = document.getElementById('connectionDistanceValue');
    const rotationSensitivitySlider = document.getElementById('rotationSensitivity');
    const rotationSensitivityValue = document.getElementById('rotationSensitivityValue');
    const zoomSensitivitySlider = document.getElementById('zoomSensitivity');
    const zoomSensitivityValue = document.getElementById('zoomSensitivityValue');
    const autoRotateCheckbox = document.getElementById('autoRotate');
    const resetBtn = document.getElementById('resetBtn');
    
    // Network parameters
    let numPoints = parseInt(pointCountSlider.value);
    let connectionsPerPoint = parseInt(connectionCountSlider.value);
    let connectionDistance = parseInt(connectionDistanceSlider.value);
    let rotationSensitivity = parseInt(rotationSensitivitySlider.value) / 100;
    let zoomSensitivity = parseInt(zoomSensitivitySlider.value) / 100;
    
    // Update display values
    pointCountSlider.addEventListener('input', function() {
      pointCountValue.textContent = this.value;
    });
    
    connectionCountSlider.addEventListener('input', function() {
      connectionCountValue.textContent = this.value;
    });
    
    connectionDistanceSlider.addEventListener('input', function() {
      connectionDistanceValue.textContent = this.value;
    });
    
    rotationSensitivitySlider.addEventListener('input', function() {
      rotationSensitivityValue.textContent = this.value;
      rotationSensitivity = parseInt(this.value) / 100;
    });
    
    zoomSensitivitySlider.addEventListener('input', function() {
      zoomSensitivityValue.textContent = this.value;
      zoomSensitivity = parseInt(this.value) / 100;
    });
    
    // Setup THREE.js scene
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 2000);
    camera.position.z = 500;
    
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(window.devicePixelRatio);
    document.body.appendChild(renderer.domElement);
    
    // Create group to hold all objects
    const networkGroup = new THREE.Group();
    scene.add(networkGroup);
    
    // Variables for transformations
    let isDragging = false;
    let previousMousePosition = { x: 0, y: 0 };
    let isPanning = false;
    let rotationSpeed = { x: 0, y: 0 };
    const damping = 0.95;
    
    // Create the network with randomly distributed points
    function createNetwork() {
      // Clear previous network
      while(networkGroup.children.length > 0) {
        const object = networkGroup.children[0];
        if (object.geometry) object.geometry.dispose();
        if (object.material) object.material.dispose();
        networkGroup.remove(object);
      }
      
      // Update parameters
      numPoints = parseInt(pointCountSlider.value);
      connectionsPerPoint = parseInt(connectionCountSlider.value);
      connectionDistance = parseInt(connectionDistanceSlider.value);
      
      // Create points with completely random distribution
      const pointsGeometry = new THREE.BufferGeometry();
      const positions = [];
      const pointSizes = [];
      
      for (let i = 0; i < numPoints; i++) {
        // Completely random position in a cube
        const x = (Math.random() - 0.5) * 400;
        const y = (Math.random() - 0.5) * 400;
        const z = (Math.random() - 0.5) * 400;
        
        positions.push(x, y, z);
        
        // Varied point sizes
        pointSizes.push(Math.random() * 2 + 1);
      }
      
      pointsGeometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
      
      // Create material with size attenuation for better depth perception
      const pointsMaterial = new THREE.PointsMaterial({
        color: 0xffffff,
        size: 2,
        sizeAttenuation: true,
        transparent: true,
        opacity: 0.8
      });
      
      const pointsSystem = new THREE.Points(pointsGeometry, pointsMaterial);
      networkGroup.add(pointsSystem);
      
      // Create random connections
      const positionArray = pointsGeometry.attributes.position.array;
      
      // First, create fixed random connections per point
      for (let i = 0; i < numPoints; i++) {
        const sourceIndex = i * 3;
        const sourcePoint = new THREE.Vector3(
          positionArray[sourceIndex],
          positionArray[sourceIndex + 1],
          positionArray[sourceIndex + 2]
        );
        
        // Create random connections for each point
        const connectedPoints = new Set();
        
        for (let c = 0; c < connectionsPerPoint; c++) {
          // Get random target point that's not already connected
          let targetIndex;
          do {
            targetIndex = Math.floor(Math.random() * numPoints);
          } while (targetIndex === i || connectedPoints.has(targetIndex));
          
          connectedPoints.add(targetIndex);
          
          targetIndex *= 3;
          const targetPoint = new THREE.Vector3(
            positionArray[targetIndex],
            positionArray[targetIndex + 1],
            positionArray[targetIndex + 2]
          );
          
          // Create line geometry
          const lineGeometry = new THREE.BufferGeometry().setFromPoints([sourcePoint, targetPoint]);
          
          const lineMaterial = new THREE.LineBasicMaterial({
            color: 0xffffff,
            transparent: true,
            opacity: 0.15
          });
          
          const line = new THREE.Line(lineGeometry, lineMaterial);
          networkGroup.add(line);
        }
      }
      
      // Then, create proximity-based connections
      for (let i = 0; i < numPoints; i++) {
        const sourceIndex = i * 3;
        const sourcePoint = new THREE.Vector3(
          positionArray[sourceIndex],
          positionArray[sourceIndex + 1],
          positionArray[sourceIndex + 2]
        );
        
        for (let j = i + 1; j < numPoints; j++) {
          const targetIndex = j * 3;
          const targetPoint = new THREE.Vector3(
            positionArray[targetIndex],
            positionArray[targetIndex + 1],
            positionArray[targetIndex + 2]
          );
          
          // Calculate distance
          const distance = sourcePoint.distanceTo(targetPoint);
          
          // Create connection if within range
          if (distance < connectionDistance) {
            // Calculate opacity based on distance
            const opacity = 0.3 * (1 - (distance / connectionDistance));
            
            // Create line geometry
            const lineGeometry = new THREE.BufferGeometry().setFromPoints([sourcePoint, targetPoint]);
            
            const lineMaterial = new THREE.LineBasicMaterial({
              color: 0xffffff,
              transparent: true,
              opacity: opacity
            });
            
            const line = new THREE.Line(lineGeometry, lineMaterial);
            networkGroup.add(line);
          }
        }
      }
    }
    
    // Initial creation
    createNetwork();
    
    // Handle controls
    resetBtn.addEventListener('click', createNetwork);
    
    // Mouse controls
    const mousePosition = new THREE.Vector2();
    
    renderer.domElement.addEventListener('mousedown', onMouseDown);
    renderer.domElement.addEventListener('mousemove', onMouseMove);
    renderer.domElement.addEventListener('mouseup', onMouseUp);
    renderer.domElement.addEventListener('wheel', onWheel);
    renderer.domElement.addEventListener('dblclick', resetCamera);
    
    function onMouseDown(event) {
      isDragging = true;
      isPanning = event.shiftKey;
      previousMousePosition = {
        x: event.clientX,
        y: event.clientY
      };
    }
    
    function onMouseMove(event) {
      mousePosition.x = (event.clientX / window.innerWidth) * 2 - 1;
      mousePosition.y = -(event.clientY / window.innerHeight) * 2 + 1;
      
      if (isDragging) {
        const deltaMove = {
          x: event.clientX - previousMousePosition.x,
          y: event.clientY - previousMousePosition.y
        };
        
        if (isPanning) {
          // Pan (translate) the network - with reduced sensitivity
          const panSpeed = 0.3;
          networkGroup.position.x += deltaMove.x * panSpeed;
          networkGroup.position.y -= deltaMove.y * panSpeed;
        } else {
          // Rotate the network - with adjustable sensitivity
          rotationSpeed.x = deltaMove.y * 0.002 * rotationSensitivity;
          rotationSpeed.y = deltaMove.x * 0.002 * rotationSensitivity;
          
          networkGroup.rotation.x += rotationSpeed.x;
          networkGroup.rotation.y += rotationSpeed.y;
        }
        
        previousMousePosition = {
          x: event.clientX,
          y: event.clientY
        };
      }
    }
    
    function onMouseUp() {
      isDragging = false;
      isPanning = false;
    }
    
    function onWheel(event) {
      event.preventDefault();
      
      // Proper zoom by moving camera position
      const zoomSpeed = 0.1 * zoomSensitivity;
      
      // Get direction vector from camera to target (origin)
      const direction = new THREE.Vector3();
      direction.subVectors(camera.position, new THREE.Vector3(0, 0, 0)).normalize();
      
      // Move camera along this direction vector
      if (event.deltaY > 0) {
        // Zoom out
        camera.position.addScaledVector(direction, 20 * zoomSpeed);
      } else {
        // Zoom in - prevent going through the center
        if (camera.position.length() > 50) {
          camera.position.addScaledVector(direction, -20 * zoomSpeed);
        }
      }
    }
    
    function resetCamera() {
      networkGroup.rotation.set(0, 0, 0);
      networkGroup.position.set(0, 0, 0);
      camera.position.set(0, 0, 500);
      camera.lookAt(0, 0, 0);
    }
    
    // Animation loop
    function animate() {
      requestAnimationFrame(animate);
      
      // Apply damping to rotation speed
      rotationSpeed.x *= damping;
      rotationSpeed.y *= damping;
      
      // Apply auto-rotation if enabled - reduced sensitivity
      if (autoRotateCheckbox.checked) {
        networkGroup.rotation.y += 0.001;
      }
      
      // Apply momentum-based rotation
      networkGroup.rotation.x += rotationSpeed.x;
      networkGroup.rotation.y += rotationSpeed.y;
      
      renderer.render(scene, camera);
    }
    
    animate();
    
    // Handle window resize
    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });
    
    // Apply changes when sliders change
    pointCountSlider.addEventListener('change', createNetwork);
    connectionCountSlider.addEventListener('change', createNetwork);
    connectionDistanceSlider.addEventListener('change', createNetwork);
  </script>
</body>
</html>